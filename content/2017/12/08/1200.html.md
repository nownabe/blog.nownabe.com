---
date: 2017-11-27T18:42:31+0900
lastmod: 2017-12-08T16:50:38+0900
tags: ["機械学習勉強会", "統計学入門"]
draft: false
isCJKLanguage: true

title: "Pythonではじめる機械学習  5回目"
category: Log

created_at: 2017-11-27 18:42:31 +0900
updated_at: 2017-12-08 16:50:38 +0900
published: true
number: 1200
---

[nownab.log | Pythonではじめる機械学習 4回目](https://blog.nownabe.com/2017/12/08/1199.html)

<iframe style="width:120px;height:240px;" marginwidth="0" marginheight="0" scrolling="no" frameborder="0" src="//rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&bc1=000000&IS2=1&bg1=FFFFFF&fc1=000000&lc1=0000FF&t=nownabe0c-22&o=9&p=8&l=as4&m=amazon&f=ifr&ref=as_ss_li_til&asins=4873117984&linkId=05656b0761603e4e9f88423f102e42c6"></iframe>

週一でやっていて、毎週読む範囲を決めて資料にまとめて発表するという感じでやっている。

また、勉強会で書いたコードや疑問点などをまとめるためにGitHubのレポジトリを活用している。
[Wondershake/machine-learning-study: 機械学習勉強会](https://github.com/Wondershake/machine-learning-study)

この記事は資料作りの下書き的扱い。

# 4章 データの表現と特徴量エンジニアリング
## 4.5 自動特徴量選択
* 特徴量を追加するとモデルは複雑になり過学習の可能性が高くなる
* 最も有用な特徴量を選択して残りを捨てると汎化性能が向上する
    * 新しい特徴量を加えるとき
    * 高次元データセットの場合
* 3つの戦略
    * **単変量統計 (univariate statistics)**
    * **モデルベース選択 (model-based selection)**
    * **反復選択 (iterative selection)**
* これらの方法はすべて教師あり手法
* 実世界のデータでは特徴量選択で大幅に性能が向上することはあまりない

### 4.5.1 単変量統計
* ターゲットとの間に統計的な関係が顕著な個々の特徴量を選択する
* **分散分析 (analysis of variance: ANOVA)**
* 個々の特徴量を個別に考慮するので、複数組み合わさって意味のある特徴量は捨てられる
* 計算が高速

### 4.5.2 モデルベース特徴量選択
* 学習済みの教師あり学習モデルにおける特徴量の重要度から選択する
    * RandomForestの重要性
    * 正則化を施した線形モデルの係数

### 4.5.3 反復特徴量選択
* 一連の教師あり学習モデルを学習して特徴量を選択する
    * 0次元から1次元ずつ特徴量を加えていく方法
    * 全特徴量から1つずつ削っていく方法
* **再帰的特徴量削減 (recursive feature elimination: RFE)
    * すべての特徴量からモデルを作る
    * 最も重要度が低い特徴量を削除する
    * 特徴量が指定された数になるまで繰り返す

## 4.6 専門家知識の利用
* 特徴量エンジニアリングに**専門家知識 (expert knowledge)**を用いることがある
* 例では、曜日周期性、時間周期性のある回帰問題で次のように特徴量を増やしていった
    * Unixtime
    * 1日の中での時刻
    * 1日の中での時刻 + 曜日
    * (1日の中での時刻 + 曜日)のOneHot表現
    * (1日の中での時刻 + 曜日)のOneHot表現の交互作用特徴量

## 4.7 まとめと展望
* 機械学習アルゴリズムに適したデータ表現が重要
    * ワンホットエンコーディング
* 特徴量の追加
    * 専門家知識
* 線形モデルはビニング、多項式特徴量、交互作用特徴量の追加の恩恵を受けやすい
* ランダムフォレストやSVMや特徴量空間の拡張なしで複雑なモデルを学習できる

# 5章 モデルの評価と改良
## 5.1 交差検証
* **交差検証 (cross-validation)**
    * 汎化性能を評価する手法
* **k分割交差検証 (k-fold cross-validation)**がよく用いられる
    * データセットをk個に分割し、順に1つの分割をテストデータとし、残りのk-1個の分割を訓練データとする

### 5.1.1 scikit-learnでの交差検証
* `cross_val_score`関数で交差検証できる

### 5.1.2 交差検証の利点
* すべてのデータが正確に1度だけテストされる
* 計算コストは単純にk倍になる

### 5.1.3 層化k分割交差検証と他の戦略
* **層化k分割交差検証 (stratified k-fold cross-validation)**ではそれぞれの正解ラベルに対して均等に分割する
* 正解ラベルに対する分割の偏りをなくす
* クラス分類では層化k分割交差検証を、回帰ではk分割交差検証を用いる

#### 5.1.3.1 交差検証のより詳細な制御
* データをシャッフルして分割するのもあり

#### 5.1.3.2 1つ抜き交差検証
* **1つ抜き交差検証 (leave-one-out)**
    * サンプルの数だけ分割する
    * 個々の分割が1サンプルのみ
    * 毎回1サンプルのみテストする
* 小さいデータセットでより良い推定ができる

#### 5.1.3.3 シャッフル分割交差検証
* **シャッフル分割交差検証 (shuffle-split cross-validation)**
    * 非常に柔軟な交差検証手法
    * 分割数やテストデータの割合、使用するデータの割合、繰り返し数などを指定できる
    * 層化バージョンもある
* 一部のデータのみ使うようにすれば大きいデータに有用

#### 5.1.3.4 グループ付き交差検証
* 未知のグループに対する予測を検証したいとき
* 例えば、
    * 表情からの感情推定で新しい人に対する推定をする
    * 新しい患者に対する推定をする
* それぞれのグループは分割されず、完全に訓練データかテストデータのどちらかになる

## 5.2 グリッドサーチ
* **グリッドサーチ (grid search)**
    * 最良のパラメータを見つける方法
    * 最もよく用いられる
    * すべてのパラメータの組み合わせを試す

### 5.2.1 単純なグリッドサーチ

### 5.2.2 パラメータの過剰適合の危険性と検証セット
* グリッドサーチの検証で用いたテストデータは最終評価には使えない
    * そのテストデータに過剰適合してるから
* グリッドサーチの検証用として訓練データをさらに分割して検証データを作る

### 5.2.3 交差検証を用いたグリッドサーチ
* グリッドサーチで汎化性能をより良く見積もるために、それぞれのパラメータの組み合わせに対して交差検証を行う

#### 5.2.3.1 交差検証の結果の解析
* 2次元のグリッドサーチならヒートマップで可視化するといい
* グリッドサーチには適切なレンジの設定が必要

#### 5.2.3.2 グリッドでないサーチ空間
#### 5.2.3.3 異なる交差検証手法を用いたグリッドサーチ
#### 5.2.3.4 ネストした交差検証
* データセットを一度だけ評価用に分割すると、その分割に評価が依存してしまう
* 最終的なスコアも交差検証によって求める
* 未来予測には使えない
* あるモデルのあるデータセットに対する性能評価に有用

#### 5.2.3.5 交差検証とグリッドサーチの並列化
* グリッドサーチは単純並列
* 並列化できる
* scikit-learnでは複数マシンの並列化は実装されていない
    * IPythonの並列化フレームワークで可能
* spark-sklearnではSparkクラスタでグリッドサーチを実行できる

# 所感
* 特にグリッドサーチ、これが学生時代にあれば…という感じ

```math
```
