---
date: 2017-11-06T17:35:01+0900
lastmod: 2017-11-08T20:17:55+0900
tags: ["機械学習勉強会", "統計学入門"]
draft: false
isCJKLanguage: true

title: "Pythonではじめる機械学習  2回目"
category: Log

created_at: 2017-11-06 17:35:01 +0900
updated_at: 2017-11-08 20:17:55 +0900
number: 1174
---

<iframe style="width:120px;height:240px;" marginwidth="0" marginheight="0" scrolling="no" frameborder="0" src="//rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&bc1=000000&IS2=1&bg1=FFFFFF&fc1=000000&lc1=0000FF&t=nownabe0c-22&o=9&p=8&l=as4&m=amazon&f=ifr&ref=as_ss_li_til&asins=4873117984&linkId=05656b0761603e4e9f88423f102e42c6"></iframe>

機械学習勉強会の続き。前回は[統計学入門](https://blog.nownabe.com/2017/10/25/1155.html)だった。

週一でやっていて、毎週読む範囲を決めて資料にまとめて発表するという感じでやっている。

また、勉強会で書いたコードや疑問点などをまとめるためにGitHubのレポジトリを活用している。
[Wondershake/machine-learning-study: 機械学習勉強会](https://github.com/Wondershake/machine-learning-study)

この記事は資料作りの下書き的扱い。

# 2章 教師あり学習
## 2.3 教師あり機械学習アルゴリズム
### 2.3.4 ナイーブベイズクラス分類気
* ナイーブベイズクラス分類器は線形モデルによく似たクラス分類器の一種
* 訓練が線形モデルより高速
* 汎化性能はロジスティック回帰や線形SVMに劣る場合が多い
* scikit-learnには3種ある
    * GaussianNB
    * BernoulliNB
    * MultinomialNB

#### 2.3.4.1 利点、欠点、パラメータ
* MultinomialNBとBernoulliNBには複雑さを制御するパラメータalphaがある
    * alphaを大きくすると複雑さは減少しスムーズになる
    * alphaの値でそんなに性能は変わらないが、いくらか精度をあげることができる
* GaussianNBは多くの場合高次元データに対して用いられる
* 他の2つは疎なカウントデータに対して用いられる
* 多くの場合MultinomialNBのほうがBernoulliNBよりも若干性能が高い
    * 特に、比較的多数の非ゼロ特徴量がある場合にMultinomialNBは有効
* ナイーブベイズモデルは線形モデルですら時間がかかりすぎるようなデータセットに対するベースラインモデルとして有用

### 2.3.5 決定木
* 決定木はクラス分類と会期に広く用いられるモデル
* Yes/Noで答えられる質問で構成された階層的な木構造を学習する

#### 2.3.5.1 決定木の構築
* 質問はtestという
* すべての可能なテストの中から目的変数に対して最も情報量の多いものを選ぶ
    * これを再帰的に繰り返して決定木を構築する
    * 対象領域に1つの対象値(1つのクラスまたは1つの回帰値)しか含まれなくなるまで繰り返す
    * 1つの対象値のデータポイントしか含まないような決定木の葉を純粋(pure)と呼ぶ
* 葉に属するデータポイントの平均値を用いることで回帰になる

#### 2.3.5.2 決定木の複雑さの制御
* 上記の方法では過学習になる
    * 訓練データに対して100%の精度
    * 深さに制約を与えないと決定木はいくらでも深く、複雑になる
* 過学習を防ぐ戦略
    * 事前枝刈り (pre-pruning) : 決定木の構築を早めに止める
    * 事後枝刈り (post-pruning) : 構築後、情報の少ないノードを削除する
* scikit-learnには事前枝刈りしか実装されていない

#### 2.3.5.3 決定木の解析
* `export_graphviz`関数で決定木を可視化できる

#### 2.3.5.4 決定木の特徴量の重要性
* 特徴量の重要度: 決定木が行う判断にとって個々の特徴量がどの程度重要かを示す割合
    * 0: まったく使われていない
    * 1: 完全に予想できる
    * 特徴量の重要度の和は1になる
    * 特徴量の重要度はあくまでもその決定木の判断にどれだけ貢献しているか
        * 特徴量の情報の量はわからない
        * 重要度の高い特徴量のみで判断できるわけではない
* 決定木による回帰は外挿ができない
    * 訓練データの範囲外の値は予測できない

#### 2.3.5.5 長所、短所、パラメータ
* パラメータは事前枝刈りパラメータ
    * max_depth, max_leaf, nodes, min_samples_leaf
* 長所
    * モデルが容易に可視化可能
    * データのスケールに対して完全に不変
        * 個々の特徴量は独立に処理されるから正規化や標準化が必要ない
        * 様々な種類の特徴量が混ざっていても問題なく機能する
* 短所
    * 最大の問題点は、事前枝刈りをしたとしても過剰適合しやすく汎化性能が低い傾向があること

### 2.3.6 決定木のアンサンブル法
* アンサンブル法は複数の機械学習モデルを組み合わせる手法
* ランダムフォレストと勾配ブースティング決定木

#### 2.3.6.1 ランダムフォレスト
* ランダムフォレストとは少しずつ異なる決定木をたくさん集めたもの
    * それぞれ異なった方向に過剰適合した決定木を作り、結果の平均を取り全体として過剰適合を防ぐ
* データをブートストラップサンプリングし個々のノードでは特徴量のサブセットをランダムに選びその中から最適な特徴量を選択し決定木を構築する
    * ブートストラップサンプリングは復元抽出で元のデータセットから同じ大きさのデータを作る
* 回帰でもクラス分類でも最も広く使われている機械学習手法
    * パラメータチューニングもほぼいらないしもスケール変換も必要ない
* 長所
    * 学習の並列化が容易
    * 非常に大きなデータセットでも機能する
* 短所
    * 大きいデータセットに対しては学習に時間がかかる
    * 乱数シードを変更すると構築されるモデルが大きく変わる可能性がある
    * テキストデータなどの高次元で疎なデータに対してはうまく機能しない傾向にある
    * 線形モデルよりも多くのメモリを消費する
    * 訓練も予測も遅い
* パラメータ
    * 決定木の数、各ノードが使う特徴量サブセットの特徴量の数、事前枝刈りのパラメータ
    * 決定木の数は大きければ大きいほど良い (時間とメモリのある限り大きくする)
    * ほかはデフォルト値を使うのが一般的
    * 枝刈りで訓練や予測の時間を短縮できる

#### 2.3.6.2 勾配ブースティング回帰木
* 回帰にもクラス分類にも使える
* 1つ前の決定木の誤りを次の決定木が修正するようにして順に決定木を構築する
* デフォルトではランダム性はない
* 強力な事前枝刈りを用い、深さ1から5ぐらいの浅い決定木を組み合わせる
    * 弱学習器
    * 使用メモリが小さくなり予測が速くなる
* ランダムフォレストに比べるとパラメータ設定の影響を受けやすい
    * パラメータさえ正しく設定すればランダムフォレストより性能はいい
* learning_rate 学習率という重要なパラメータがある
    * 個々の決定木がそれまでの決定木の過ちをどれぐらい強く補正しようとするか
    * 学習率を大きくするとモデルは複雑になる
* 決定木の数を増やしてもモデルは複雑になる
* 勾配ブースティングとランダムフォレストが得意なデータは同じ
    * 先に頑健なランダムフォレストを試す
    * 予測時間や1%の性能が重要な場合は勾配ブースティングを試す
* 勾配ブースティングはscikit-learnよりxgboostのほうがおすすめ
* 長所
    * 特徴量のスケール変換が必要ない
    * 様々な種類の特徴量が混ざっていても機能する
* 短所
    * パラメータチューニングに最新の注意が必要
    * 訓練時間が長い
    * 高次元で疎なデータに弱い
* パラメータ
    * 決定木の数
        * ランダムフォレストと違い、多すぎると過学習する
    * 誤り補正の度合い (学習率)
    * 事前枝刈り

### 2.3.7 カーネル法を用いたサポートベクタマシン
* 複雑なモデルを可能にするため線形SVMを拡張したもの
* クラス分類にも回帰にも利用できる

#### 2.3.7.1 線形モデルと非線形特徴量
* 線形モデルで分離できないようなデータセットに非線形な特徴量を加えることで線形モデルが協力に効くようになる
* どのように特徴量を加えるかという問題がある
* カーネルトリック: 特徴量を増やさず高次元空間へマッピングする数学的トリック
    * 多項式カーネル (polynomial kernel): もとの特徴量の特定の次数までのすべての多項式を計算する
    * 放射基底関数 (radial basis function : RBF) カーネル
    * ガウシアンカーネル

#### 2.3.7.2 SVMを理解する
* サポートベクタ: 境界を決定するごく一部のデータポイント
* 予測を行うとき、サポートベクタとデータポイントとの距離とサポートベクタの重要性によってクラスが決定される

#### 2.3.7.4 SVMパラメータの調整
* gamma: ガウシアンカーネルの幅を調整する
    * 点が近いということを意味するスケールを決定する
    * gammaが小さいと、多くの点を近いと判断するようになる
    * gammaが小さいと、複雑さは小さくなる
* C: 線形モデルと同様の正則化パラメータ
    * 小さいと正則化が強い
    * 小さいと複雑さは小さくなる
* SVMはパラメータの設定とデータのスケールに敏感
    * すべての特徴量の変位が同じスケールであることを要求する

#### 2.3.7.5 SVMのためのデータの前処理
* すべての特徴量が0から1の間になるようにスケールを変換する

#### 2.3.7.6 利点、欠点、パラメータ
* 利点
    * さまざまなデータセットに上手く機能する
    * データに僅かな特徴量しかない場合でも複雑な決定境界を生成できる
    * 低次元でも高次元でもうまく機能する
* 欠点
    * サンプル数が大きくなるとうまく機能しない
        * 10,000個ぐらいまでならうまく機能するが100,000個ぐらいになると実行時間やメモリ消費量で難しくなる
    * データの前処理とパラメータ調整を注意深く行う必要がある
    * 検証が難しい
* パラメータ
    * 正則化パラメータC
    * カーネルの種類
    * カーネルのパラメータ

### 2.3.8 ニューラルネットワーク (ディープラーニング)
#### 2.3.8.1 ニューラルネットワークモデル
* 多層パーセプトロン (multilayer perceptron : MLP) は線形モデルを一般化し、決定までに複数のステージで計算するものと見ることができる
* 隠層で重み付き和にrelu(rectified linear unit: 正規化線形関数)やtanh (hyperblic tangent : 双極正接関数)などの非線形関数を適用することで、線形モデルよりも強力にする

#### 2.3.8.2 ニューラルネットワークのチューニング
* 隠れ層のユニット数を増やせば複雑になる
* 隠れ層の数を増やせば複雑になる
* 正則化パラメータalphaを大きくすれば正則化が強くなる
* 多くのパラメータがある
* 学習の初期値を乱数で割り当てるので、乱数値がモデルに影響を与える
* ニューラルネットワークもSVMと同様にすべての特徴量が同じスケールであることを前提としている
    * 理想は平均が0で分散が1
* より柔軟な、もしくはより大きなモデルを使いたいならscikit-learnではなくディープラーニングのライブラリを使うべき
    * keras, lasagna, tensor-flow

#### 2.3.8.3 長所、短所、パラメータ
* 長所
    * 大量のデータを利用して複雑なモデルを構築できる
    * 十分な計算時間、データがあり慎重にパラメータ調整すれば他のアルゴリズムに勝てることが多い
* 短所
    * 訓練に時間がかかる
    * データを慎重に前処理する必要がある
* パラメータ
    * 最も重要なのは隠れ層の数とユニット数
        * 隠れ層は1つか2つから始める
        * ユニット数は入力層と同じぐらいにすることが多いが、数千より大きくなることはあまりない
    * 最初は過剰適合できるように大きなネットワークを作って、訓練データを学習できるか確かめる
        * ネットワークを小さくするか正則化を強くして汎化性能をあげる

## 2.4 クラス分類器の不確実性推定
* scikit-learnにはクラス分類器の予測に対する不確実性推定機能がある

### 2.4.1 決定関数 (Decision Function)
* モデルがデータポイントが陽性/陰性だとどれぐらい信じているかという度合いを出す関数

### 2.4.2 確率の予測
* 各クラスへの分類の予測確率
* 確信度が実際の正答率と一致している場合、較正されているという

### 2.4.3 他クラス分類の不確実性
* 確信度が最も大きいクラスが予測として選ばれる

## 2.5 まとめと展望
* モデルの複雑さと汎化
* 適合不足と過剰適合
* 性能を出すには適切なパラメータが必要
* 特徴量のスケールに注意
* アルゴリズム
    * 最近傍法
        * 小さいデータに関しては良いベースラインになる
        * 説明が容易
    * 線形モデル
        * 高速
        * 最初に試すべきアルゴリズム
        * 大きなデータセットに適する
        * 高次元データに適する
    * ナイーブベイズ
        * クラス分類のみ
        * 線形モデルより高速
        * 大きなデータセットに適する
        * 高次元データに適する
        * 線形モデルより精度が劣る
    * 決定木
        * 非常に高速
        * 特徴量のスケールを考慮する必要がない
        * 可視化が可能
    * ランダムフォレスト
        * 単一の決定木より高速、頑健、強力
        * 特徴量のスケールを考慮する必要がない
        * 高次元で疎なデータには適さない
    * 勾配ブースティング決定木
        * ランダムフォレストより少し精度が高い
        * ランダムフォレストより訓練に時間がかかるが、予測は速い
        * ランダムフォレストよりメモリ使用量が小さい
        * パラメータに敏感
    * SVM
        * 同じような意味を持つ特徴量からなる中規模データセットに対して強力
        * 特徴量のスケールを調整する必要がある
        * パラメータに敏感
    * ニューラルネットワーク
        * 非常に複雑なモデルを構築できる
        * 大きなデータセットに有効
        * 特徴量のスケールを調整する必要がある
        * パラメータに敏感
        * 訓練に時間がかかる


# 所感
* いろんな種類のアルゴリズムを比較してこれはこうでこれに向いているみたいなのはやったことがなかったので、とても参考になった

```math
```
